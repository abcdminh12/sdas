<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Infinity Legends: Final Deployment</title>
    <style>
      :root {
        --main: #f1c40f;
        --bg: #050505;
        --panel: rgba(15, 15, 20, 0.96);
        --danger: #e74c3c;
        --success: #2ecc71;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: radial-gradient(ellipse at center, #081018 0%, #020204 60%);
        font-family: "Consolas", "Segoe UI", monospace;
        color: #fff;
        overflow: hidden;
        user-select: none;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      #ui-layer {
        position: absolute;
        inset: 0;
        pointer-events: none;
        display: flex;
        flex-direction: column;
      }
      .hud-top {
        display: flex;
        justify-content: space-between;
        padding: 14px 26px;
        background: linear-gradient(180deg, rgba(0, 0, 0, 0.6), transparent);
        font-size: 18px;
        pointer-events: none;
      }
      .hud-bottom {
        margin-top: auto;
        padding: 18px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        pointer-events: none;
      }
      .quick-slots {
        display: flex;
        gap: 15px;
        margin-bottom: 10px;
        pointer-events: auto;
        z-index: 50;
      }
      .q-slot {
        width: 54px;
        height: 54px;
        border-radius: 50%;
        background: rgba(20, 20, 20, 0.9);
        border: 2px solid #444;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        cursor: pointer;
        position: relative;
        transition: 0.2s;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
      }
      .q-slot:hover {
        border-color: var(--main);
        transform: scale(1.1) translateY(-5px);
        box-shadow: 0 0 15px var(--main);
      }
      .q-count {
        position: absolute;
        bottom: -2px;
        right: -2px;
        background: var(--danger);
        color: white;
        font-size: 11px;
        font-weight: bold;
        padding: 2px 6px;
        border-radius: 10px;
        border: 1px solid #fff;
      }
      .bar-wrap {
        width: 640px;
        height: 28px;
        background: #0b0b0b88;
        border: 1px solid rgba(255, 255, 255, 0.04);
        border-radius: 6px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
      }
      .bar-fill {
        height: 100%;
        transition: width 0.18s cubic-bezier(0.2, 0.9, 0.2, 1);
        position: absolute;
        left: 0;
        top: 0;
      }
      .hp-fill {
        background: linear-gradient(90deg, #c0392b, #e74c3c);
      }
      .exp-fill {
        background: linear-gradient(90deg, #2980b9, #3498db);
        height: 8px;
        border-radius: 4px;
      }
      .bar-txt {
        position: absolute;
        width: 100%;
        text-align: center;
        line-height: 28px;
        font-size: 13px;
        text-shadow: 1px 1px 2px #000;
        z-index: 2;
      }
      .interactive {
        pointer-events: auto;
      }
      .btn {
        background: rgba(20, 20, 22, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.04);
        color: #ddd;
        padding: 10px 14px;
        cursor: pointer;
        transition: 0.15s;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        border-radius: 6px;
      }
      .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
        border-color: var(--main);
        color: var(--main);
      }
      .btn-menu {
        width: 220px;
        margin: 10px auto;
        display: block;
        pointer-events: auto;
      }
      .screen {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.86);
        z-index: 100;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        pointer-events: auto;
        padding: 20px;
      }
      .panel {
        background: var(--panel);
        border: 2px solid rgba(241, 196, 15, 0.14);
        padding: 22px;
        border-radius: 12px;
        width: 86%;
        max-width: 1000px;
        max-height: 84vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.8);
      }
      .panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 14px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        padding-bottom: 8px;
        font-size: 22px;
        color: var(--main);
      }
      .grid-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(210px, 1fr));
        gap: 12px;
        overflow-y: auto;
        padding: 8px;
      }
      .card {
        background: #151515;
        padding: 12px;
        border: 1px solid rgba(255, 255, 255, 0.03);
        cursor: pointer;
        position: relative;
        transition: 0.12s;
        display: flex;
        flex-direction: column;
        gap: 6px;
        border-radius: 8px;
      }
      .card:hover {
        transform: translateY(-6px) scale(1.01);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
        border-color: var(--main);
      }
      .rarity-0 {
        border-left: 4px solid #bdc3c7;
      }
      .rarity-1 {
        border-left: 4px solid #3498db;
      }
      .rarity-2 {
        border-left: 4px solid #9b59b6;
      }
      .rarity-3 {
        border-left: 4px solid #e67e22;
        box-shadow: 0 0 14px rgba(230, 126, 34, 0.2);
      }
      .rarity-4 {
        border-left: 4px solid #e74c3c;
        box-shadow: 0 0 18px rgba(231, 76, 60, 0.3);
      }
      .rarity-5 {
        border-left: 4px solid #f1c40f;
        box-shadow: 0 0 24px rgba(241, 196, 15, 0.5);
        animation: pulse border 2s infinite;
      }
      .rarity-cons {
        border-left: 4px solid #2ecc71;
      }
      .card-tag {
        position: absolute;
        top: 8px;
        right: 8px;
        font-size: 11px;
        padding: 3px 6px;
        background: var(--success);
        color: black;
        font-weight: bold;
        border-radius: 4px;
      }
      #noti-area {
        position: absolute;
        top: 20%;
        width: 100%;
        text-align: center;
        pointer-events: none;
        z-index: 80;
      }
      .noti-msg {
        display: inline-block;
        font-size: 34px;
        color: var(--success);
        text-shadow: 0 0 24px var(--success);
        animation: popUp 2s forwards;
        padding: 6px 12px;
        border-radius: 6px;
        background: linear-gradient(
          90deg,
          rgba(46, 204, 113, 0.08),
          rgba(46, 204, 113, 0.03)
        );
      }
      @keyframes popUp {
        0% {
          opacity: 0;
          transform: translateY(18px) scale(0.9);
        }
        20% {
          opacity: 1;
          transform: translateY(0) scale(1.05);
        }
        100% {
          opacity: 0;
          transform: translateY(-50px);
        }
      }
      .talent-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #141414;
        padding: 12px;
        margin-bottom: 8px;
        border-radius: 8px;
      }
      .hud-left-buttons {
        position: absolute;
        top: 86px;
        left: 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        pointer-events: auto;
      }
      .monster-hud {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        width: 300px;
        background: rgba(0, 0, 0, 0.85);
        border: 2px solid #ff4500;
        color: #fff;
        padding: 15px;
        border-radius: 10px;
        z-index: 90;
        box-shadow: 0 0 15px #ff4500;
        transition: opacity 0.3s;
        pointer-events: none;
        opacity: 0;
      }
      .monster-hud.active {
        opacity: 1;
      }
      .monster-hud h3 {
        margin: 0 0 10px 0;
        color: #ffcc00;
        text-transform: uppercase;
        text-align: center;
        border-bottom: 1px solid #555;
        padding-bottom: 5px;
      }
      .inv-emoji {
        font-size: 20px;
        margin-right: 6px;
      }
      .fps {
        font-size: 12px;
        color: #bbb;
      }
    </style>
  </head>
  <body>
    <div id="ui-layer">
      <div class="hud-top">
        <div>STAGE <span id="ui-stage" style="color: var(--main)">1</span></div>
        <div><span id="ui-kill">0</span> / <span id="ui-req">10</span> üíÄ</div>
        <div><span id="ui-coin" style="color: gold">0</span> $</div>
        <div><span id="ui-fps" class="fps">60 FPS</span></div>
      </div>
      <div id="monster-hud" class="monster-hud">
        <h3 id="m-name">T√™n Qu√°i</h3>
        <div class="m-stats">
          <p>‚öîÔ∏è S·ª©c m·∫°nh: <span id="m-power">0</span></p>
          <p>üõ°Ô∏è M√°u: <span id="m-hp">0</span></p>
        </div>
        <div class="m-desc">
          <p>‚ö†Ô∏è <strong>K·ªπ nƒÉng:</strong> <span id="m-skill">...</span></p>
        </div>
      </div>
      <div class="hud-left-buttons">
        <button class="btn interactive" id="btn-inv">üéí T√∫i ƒê·ªì (B)</button>
        <button class="btn interactive" id="btn-shop">üõí Shop (P)</button>
        <button class="btn interactive" id="btn-tal">üß† K·ªπ NƒÉng (T)</button>
        <button class="btn interactive" id="btn-save">üíæ L∆∞u Game</button>
      </div>
      <div id="noti-area"></div>
      <div class="hud-bottom">
        <div class="quick-slots" id="quick-slots"></div>
        <div class="bar-wrap">
          <div class="bar-fill hp-fill" id="bar-hp"></div>
          <div class="bar-txt" id="txt-hp">HP</div>
        </div>
        <div class="bar-wrap" style="height: 10px">
          <div class="bar-fill exp-fill" id="bar-exp"></div>
        </div>
        <div style="font-size: 12px; color: #bbb">
          WASD: Di chuy·ªÉn | Chu·ªôt: B·∫Øn | Space: L∆∞·ªõt
        </div>
      </div>
    </div>

    <div id="screen-inventory" class="screen">
      <div class="panel">
        <div class="panel-header">
          <span>EQUIPMENT ONLY</span
          ><button class="btn" onclick="Game.UI.closeAll()">ƒê√ìNG (ESC)</button>
        </div>
        <div class="grid-container" id="grid-inv"></div>
      </div>
    </div>
    <div id="screen-shop" class="screen">
      <div class="panel">
        <div class="panel-header">
          <span>WEAPON & POTION SHOP</span
          ><button class="btn" onclick="Game.UI.closeAll()">ƒê√ìNG (ESC)</button>
        </div>
        <div class="grid-container" id="grid-shop"></div>
      </div>
    </div>
    <div id="screen-talents" class="screen">
      <div class="panel">
        <div class="panel-header">
          <span>TALENT TREE</span
          ><button class="btn" onclick="Game.UI.closeAll()">ƒê√ìNG (ESC)</button>
        </div>
        <div id="list-talents" style="overflow-y: auto"></div>
      </div>
    </div>

    <div id="screen-start" class="screen" style="display: flex">
      <div style="text-align: center">
        <h1
          style="
            font-size: 56px;
            color: var(--main);
            text-shadow: 0 0 40px var(--main);
            margin: 8px 0;
          "
        >
          INFINITY LEGENDS
        </h1>
        <p style="opacity: 0.8">AUTO MODE (Cloud Save Enabled)</p>
        <input
          type="text"
          id="inp-userid"
          placeholder="Nh·∫≠p t√™n ƒëƒÉng nh·∫≠p..."
          style="
            padding: 10px;
            width: 220px;
            border-radius: 5px;
            border: 1px solid #555;
            background: #222;
            color: #fff;
            margin-bottom: 10px;
            text-align: center;
          "
        />
        <br />
        <button class="btn btn-menu interactive" onclick="Game.startNew()">
          B·∫ÆT ƒê·∫¶U M·ªöI
        </button>
        <button
          class="btn btn-menu interactive"
          onclick="Game.loadFromHybrid()"
        >
          TI·∫æP T·ª§C (LOAD)
        </button>
      </div>
    </div>

    <div id="screen-over" class="screen">
      <div style="text-align: center">
        <h1 style="color: var(--danger); font-size: 72px; margin: 4px 0">
          YOU DIED
        </h1>
        <p>B·∫°n ƒë√£ d·ª´ng b∆∞·ªõc t·∫°i Stage <span id="over-stage"></span></p>
        <button class="btn btn-menu interactive" onclick="location.reload()">
          CH∆†I L·∫†I
        </button>
      </div>
    </div>
    <canvas id="cvs"></canvas>

    <script>
      // S·ª¨A ƒê·ªîI QUAN TR·ªåNG: ƒê·ªÉ chu·ªói r·ªóng ƒë·ªÉ t·ª± nh·∫≠n di·ªán domain hi·ªán t·∫°i
      // Khi up l√™n Render n√≥ s·∫Ω hi·ªÉu l√† https://ten-app.onrender.com
      // T·ª± ƒë·ªông l·∫•y domain hi·ªán t·∫°i, d√π l√† localhost hay Render
      const API_URL = "";

      const Config = {
        w: innerWidth,
        h: innerHeight,
        dpr: Math.max(1, devicePixelRatio || 1),
        colors: [
          "#bdc3c7",
          "#3498db",
          "#9b59b6",
          "#e67e22",
          "#e74c3c",
          "#f1c40f",
        ],
        prefixes: [
          { name: "G·ªó", mul: 0.8, emoji: "ü™µ" },
          { name: "S·∫Øt", mul: 1, emoji: "‚õìÔ∏è" },
          { name: "Th√©p", mul: 1.2, emoji: "üõ°Ô∏è" },
          { name: "Titan", mul: 1.4, emoji: "üí†" },
          { name: "H·∫Øc √Åm", mul: 1.8, emoji: "üíÄ" },
          { name: "Th·∫ßn Tho·∫°i", mul: 3.0, emoji: "üåü" },
        ],
        talents: [
          { id: "hp", name: "Vitality (Max HP)", base: 200, inc: 120, val: 20 },
          { id: "dmg", name: "Strength (Damage)", base: 250, inc: 150, val: 2 },
          { id: "spd", name: "Agility (Speed)", base: 300, inc: 200, val: 0.2 },
          { id: "greed", name: "Greed (Gold)", base: 500, inc: 500, val: 0.1 },
        ],
      };
      const Utils = {
        rand: (a, b) => Math.random() * (b - a) + a,
        randInt: (a, b) => Math.floor(Math.random() * (b - a) + a),
        dist: (x1, y1, x2, y2) => Math.hypot(x1 - x2, y1 - y2),
        uuid: () => Math.random().toString(36).substr(2, 9),
        lerp: (a, b, t) => a + (b - a) * t,
        now: () => performance.now(),
      };

      const MusicSystem = {
        bgMusic: null,
        isPlaying: false,
        init() {
          this.bgMusic = new Audio(
            "https://commondatastorage.googleapis.com/codeskulptor-assets/Epoq-Lepidoptera.ogg"
          );
          this.bgMusic.loop = true;
          this.bgMusic.volume = 0.3;
        },
        startBattleMusic() {
          if (!this.bgMusic) this.init();
          if (this.isPlaying) return;
          this.bgMusic
            .play()
            .then(() => {
              this.isPlaying = true;
            })
            .catch((e) => console.log("Music blocked"));
        },
        stop() {
          if (this.bgMusic) {
            this.bgMusic.pause();
            this.bgMusic.currentTime = 0;
            this.isPlaying = false;
          }
        },
      };

      class Portal {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.angle = 0;
          this.r = 0;
          this.targetR = 50;
          this.particles = [];
          this.active = true;
        }
        update() {
          this.angle += 0.05;
          if (this.r < this.targetR) this.r += 0.5;
          if (Game.frame % 3 === 0) {
            let ang = Math.random() * Math.PI * 2;
            let dist = 100 + Math.random() * 50;
            this.particles.push({
              x: this.x + Math.cos(ang) * dist,
              y: this.y + Math.sin(ang) * dist,
              life: 60,
              maxLife: 60,
            });
          }
          for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            let d = Math.hypot(this.x - p.x, this.y - p.y);
            p.x += ((this.x - p.x) / d) * 4;
            p.y += ((this.y - p.y) / d) * 4;
            p.life--;
            if (d < 10 || p.life <= 0) this.particles.splice(i, 1);
          }
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);
          ctx.globalCompositeOperation = "lighter";
          let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, this.r);
          grad.addColorStop(0, "#000");
          grad.addColorStop(0.5, "#2ecc71");
          grad.addColorStop(1, "transparent");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(0, 0, this.r * 1.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#aaffcc";
          ctx.lineWidth = 3;
          for (let i = 0; i < 4; i++) {
            ctx.rotate(Math.PI / 2);
            ctx.beginPath();
            ctx.moveTo(10, 0);
            ctx.quadraticCurveTo(this.r, this.r / 2, this.r, 0);
            ctx.stroke();
          }
          ctx.restore();
          ctx.save();
          ctx.fillStyle = "#fff";
          this.particles.forEach((p) => {
            ctx.globalAlpha = p.life / p.maxLife;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
          });
          ctx.restore();
        }
      }

      class ItemGenerator {
        static createConsumable(level) {
          let types = [
            {
              id: "pot_hp",
              name: "B√¨nh M√°u",
              price: 150,
              val: 50,
              type: "HEAL",
              emo: "‚ù§Ô∏è",
            },
            {
              id: "pot_spd",
              name: "TƒÉng T·ªëc",
              price: 300,
              val: 10,
              type: "BUFF_SPD",
              emo: "‚ö°",
            },
            {
              id: "pot_dmg",
              name: "Cu·ªìng N·ªô",
              price: 600,
              val: 10,
              type: "BUFF_DMG",
              emo: "üëπ",
            },
          ];
          let base = types[Utils.randInt(0, types.length)];
          return {
            id: Utils.uuid(),
            type: "CONSUMABLE",
            rarity: "cons",
            level: 1,
            name: base.name,
            price: base.price,
            stats: { effect: base.type, val: base.val },
            emoji: base.emo,
            desc:
              base.type === "HEAL"
                ? `H·ªìi ${base.val} HP`
                : `Buff ch·ªâ s·ªë t·∫°m th·ªùi`,
          };
        }
        static create(level, forceRarity = -1, bonusMultiplier = 1) {
          if (Math.random() < 0.2 && forceRarity === -1)
            return this.createConsumable(level);
          let type = Math.random() > 0.3 ? "WEAPON" : "ARMOR";
          let rarity = 0;
          if (forceRarity !== -1) rarity = forceRarity;
          else {
            let roll = Math.random() * 100;
            if (roll <= 0.2) rarity = 5;
            else if (roll <= 2.5) rarity = 4;
            else if (roll <= 10.0) rarity = 3;
            else if (roll <= 30.0) rarity = 2;
            else if (roll <= 60.0) rarity = 1;
          }
          let pref = Config.prefixes[rarity];
          let powerScale = (1 + level * 0.08) * pref.mul * bonusMultiplier;
          let item = {
            id: Utils.uuid(),
            type,
            rarity,
            level,
            name: `${pref.name} ${type === "WEAPON" ? "VK" : "Gi√°p"}`,
            price: Math.floor(300 * powerScale),
            stats: {},
            emoji: pref.emoji,
          };
          if (type === "WEAPON") {
            let weapons = [
              { n: "L·ª•c", d: 10, r: 20, m: 1, emo: "üî´", style: "PISTOL" },
              { n: "Ti·ªÉu Li√™n", d: 5, r: 5, m: 1, emo: "üñäÔ∏è", style: "SMG" },
              { n: "Shotgun", d: 7, r: 45, m: 5, emo: "üß®", style: "SHOTGUN" },
              { n: "T·ªâa", d: 45, r: 65, m: 1, emo: "üî≠", style: "SNIPER" },
              { n: "Plasma", d: 20, r: 15, m: 1, emo: "üîÆ", style: "PLASMA" },
              { n: "Laser", d: 4, r: 3, m: 1, emo: "üî¶", style: "LASER" },
              { n: "ƒê·∫°i B√°c", d: 60, r: 80, m: 1, emo: "üí£", style: "CANNON" },
              { n: "Minigun", d: 4, r: 4, m: 1, emo: "üî•", style: "MINIGUN" },
              {
                n: "N·ªè Th·∫ßn",
                d: 30,
                r: 35,
                m: 1,
                emo: "üèπ",
                style: "CROSSBOW",
              },
            ];
            let base = weapons[Utils.randInt(0, weapons.length)];
            item.name = `${pref.name} ${base.n}`;
            item.emoji = base.emo;
            item.subType = base.style;
            let rawDmg = Math.floor(base.d * powerScale);
            let rawRate = Math.max(
              3,
              Math.floor(base.r / Math.max(1, powerScale / 2))
            );
            item.stats = {
              dmg: rawDmg,
              rate: rawRate,
              multi: base.m,
              crit: +(rarity * 0.05).toFixed(2),
            };
            if (base.style === "CROSSBOW") item.stats.crit += 0.2;
            if (base.style === "MINIGUN") item.stats.rate = 3;
          } else {
            item.stats = { hp: Math.floor(50 * powerScale) };
            item.name = `${pref.name} Gi√°p`;
            if (rarity >= 3) {
              item.emoji = "üõ°Ô∏è";
              item.price = Math.floor(item.price * 1.5);
            }
          }
          return item;
        }
      }

      class Entity {
        constructor(x, y, r, color) {
          this.x = x;
          this.y = y;
          this.r = r;
          this.color = color;
          this.dead = false;
          this.vx = 0;
          this.vy = 0;
          this.id = Utils.uuid();
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
        }
        draw(ctx) {
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(0, 0, this.r, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      class Player extends Entity {
        constructor() {
          super(0, 0, 18, "#3aa0ff");
          this.baseStats = { hp: 120, dmg: 12, spd: 4.2 };
          this.talents = { hp: 0, dmg: 0, spd: 0, greed: 0 };
          this.curHp = 120;
          this.level = 1;
          this.exp = 0;
          this.req = 120;
          this.gold = 0;
          this.inv = [];
          this.equip = { wp: null, ar: null };
          this.angle = 0;
          this.shootTimer = 0;
          this.dashCd = 0;
          this.invincible = 0;
          this.buffs = { spd: 0, dmg: 0 };
          this.buffTimer = 0;
        }
        get stats() {
          let s = {
            maxHp: this.baseStats.hp + this.talents.hp * 20,
            dmg: this.baseStats.dmg + this.talents.dmg * 2,
            spd: this.baseStats.spd + this.talents.spd * 0.2,
            rate: 20,
            multi: 1,
            crit: 0,
            style: "PISTOL",
          };
          if (this.equip.ar) s.maxHp += this.equip.ar.stats.hp || 0;
          if (this.equip.wp) {
            s.dmg += this.equip.wp.stats.dmg || 0;
            s.rate = this.equip.wp.stats.rate || s.rate;
            s.multi = this.equip.wp.stats.multi || 1;
            s.crit = this.equip.wp.stats.crit || 0;
            s.style = this.equip.wp.subType || "PISTOL";
          }
          if (this.buffTimer > 0) {
            s.spd += this.buffs.spd;
            s.dmg += this.buffs.dmg;
          }
          return s;
        }
        update(input, cam) {
          let s = this.stats;
          if (this.buffTimer > 0) this.buffTimer--;
          let dx = 0,
            dy = 0;
          if (input.w) dy = -1;
          if (input.s) dy = 1;
          if (input.a) dx = -1;
          if (input.d) dx = 1;
          if (input.space && this.dashCd <= 0 && (dx || dy)) {
            this.dashCd = 60;
            this.vx = (dx || 0) * 26;
            this.vy = (dy || 0) * 26;
            Game.fx.add(this.x, this.y, "DASH!", "#fff", true);
            Game.snd.playDash();
          } else {
            this.vx = Utils.lerp(this.vx, 0, 0.12);
            this.vy = Utils.lerp(this.vy, 0, 0.12);
            if (dx || dy) {
              let len = Math.hypot(dx, dy) || 1;
              this.x += (dx / len) * s.spd;
              this.y += (dy / len) * s.spd;
            }
          }
          super.update();
          if (this.dashCd > 0) this.dashCd--;
          if (this.invincible > 0) this.invincible--;
          this.angle = Math.atan2(
            input.my + cam.y - this.y,
            input.mx + cam.x - this.x
          );
          if (this.curHp < s.maxHp)
            this.curHp += Math.max(0.001, s.maxHp * 0.00005);
          if (input.mouse && this.shootTimer <= 0) {
            this.shoot(s);
            this.shootTimer = s.rate;
          }
          if (this.shootTimer > 0) this.shootTimer--;
        }
        shoot(s) {
          let spread = 0.1;
          if (s.style === "SHOTGUN") spread = 0.3;
          if (s.style === "MINIGUN") spread = 0.25;
          let start = this.angle - ((s.multi - 1) * spread) / 2;
          for (let i = 0; i < s.multi; i++) {
            let isCrit = Math.random() < s.crit;
            let finalDmg =
              s.style === "MINIGUN" || s.style === "LASER"
                ? Math.max(1, s.dmg * 0.6)
                : s.dmg;
            if (isCrit) finalDmg *= 2;
            Game.world.bullets.push(
              new Bullet(
                this.x + Math.cos(this.angle) * 12,
                this.y + Math.sin(this.angle) * 12,
                start + i * spread,
                finalDmg,
                true,
                isCrit,
                s.style
              )
            );
          }
          if (s.style !== "LASER")
            Game.fx.burstTrail(this.x, this.y, this.angle);
          Game.snd.playShoot(s.style);
        }
        useItem(item) {
          if (item.type !== "CONSUMABLE") return false;
          let used = false;
          if (item.stats.effect === "HEAL") {
            if (this.curHp < this.stats.maxHp) {
              this.curHp = Math.min(
                this.curHp + item.stats.val,
                this.stats.maxHp
              );
              Game.fx.add(this.x, this.y, `+${item.stats.val} HP`, "#2ecc71");
              Game.snd.playPowerUp();
              used = true;
            } else Game.fx.notify("ƒê√£ ƒë·∫ßy m√°u!");
          } else if (item.stats.effect === "BUFF_SPD") {
            this.buffs.spd = 3;
            this.buffTimer = 600;
            Game.fx.notify("TƒÉng T·ªëc ƒê·ªô!");
            Game.snd.playPowerUp();
            used = true;
          } else if (item.stats.effect === "BUFF_DMG") {
            this.buffs.dmg = 20;
            this.buffTimer = 600;
            Game.fx.notify("Cu·ªìng N·ªô!");
            Game.snd.playPowerUp();
            used = true;
          }
          return used;
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.rotate(this.angle);
          if (this.invincible > 0 && Game.frame % 6 < 3) ctx.globalAlpha = 0.5;
          let grad = ctx.createLinearGradient(-this.r, -this.r, this.r, this.r);
          grad.addColorStop(0, "#3aa0ff");
          grad.addColorStop(1, "#2a6fb8");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(0, 0, this.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#111";
          ctx.fillRect(10, -6, 26, 12);
          ctx.fillStyle = "#ddd";
          ctx.fillRect(12, -4, 18, 8);
          ctx.restore();
          if (this.buffTimer > 0) {
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.strokeStyle = this.buffs.dmg > 0 ? "#e74c3c" : "#f1c40f";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(
              this.x,
              this.y,
              22 + Math.sin(Game.frame * 0.2) * 4,
              0,
              Math.PI * 2
            );
            ctx.stroke();
            ctx.restore();
          }
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          let grad2 = ctx.createRadialGradient(
            this.x,
            this.y,
            0,
            this.x,
            this.y,
            120
          );
          grad2.addColorStop(0, "rgba(60,160,255,0.12)");
          grad2.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grad2;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 120, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
      class Enemy extends Entity {
        constructor(type, level) {
          let ang = Math.random() * Math.PI * 2;
          let d = 520 + Math.random() * 300;
          let px = Game.player ? Game.player.x : 0,
            py = Game.player ? Game.player.y : 0;
          super(px + Math.cos(ang) * d, py + Math.sin(ang) * d, 16, "#e74c3c");
          let scale = 1 + level * 0.15;
          this.hp = 36 * scale;
          this.maxHp = this.hp;
          this.dmg = 6 * scale;
          this.spd = 1.8 + Math.random() * 1.6;
          this.type = type;
          this.chargeTimer = 0;
          this.telegraph = 0;
          this.skillDesc = "Lao v√†o t·∫•n c√¥ng";
          this.name = "Qu√°i V·∫≠t";
          if (type === 1) {
            this.hp *= 3;
            this.spd *= 0.5;
            this.r = 30;
            this.color = "#34495e";
            this.name = "Tanker";
            this.skillDesc = "H√∫c m·∫°nh khi l·∫°i g·∫ßn";
          } else if (type === 2) {
            this.hp *= 0.6;
            this.spd *= 1.8;
            this.r = 12;
            this.color = "#e74c3c";
            this.name = "S√°t Th·ªß";
            this.skillDesc = "Di chuy·ªÉn c·ª±c nhanh";
          }
        }
        update() {
          let p = Game.player;
          if (!p) return;
          let dx = p.x - this.x,
            dy = p.y - this.y;
          let dist = Math.hypot(dx, dy);
          if (this.type === 1 && this.chargeTimer <= 0 && dist < 220) {
            this.chargeTimer = 120;
            this.telegraph = 30;
          }
          if (this.telegraph > 0) {
            this.telegraph--;
            if (this.telegraph === 0) {
              let ang = Math.atan2(dy, dx);
              this.vx = Math.cos(ang) * 8;
              this.vy = Math.sin(ang) * 8;
            }
          } else if (this.chargeTimer > 0) {
            this.chargeTimer--;
            if (this.chargeTimer === 0) {
              this.vx = 0;
              this.vy = 0;
            }
          } else {
            if (dist > 0) {
              this.x += (dx / dist) * this.spd;
              this.y += (dy / dist) * this.spd;
            }
          }
          super.update();
          if (dist < this.r + p.r && p.invincible <= 0) {
            p.curHp -= this.dmg;
            p.invincible = 28;
            Game.cam.shake = Math.max(Game.cam.shake, 8);
            Game.cam.blood = 1.0;
            Game.fx.add(p.x, p.y, `-${Math.floor(this.dmg)}`, "#ff8888");
            Game.snd.playHurt();
            if (p.curHp <= 0) Game.over();
          }
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          let g = ctx.createLinearGradient(-this.r, -this.r, this.r, this.r);
          g.addColorStop(0, this.color);
          g.addColorStop(1, "#110000");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(0, 0, this.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#222";
          ctx.fillRect(-this.r, -this.r - 10, this.r * 2, 6);
          ctx.fillStyle = "#e74c3c";
          ctx.fillRect(
            -this.r,
            -this.r - 10,
            this.r * 2 * (this.hp / this.maxHp),
            6
          );
          if (this.telegraph > 0) {
            ctx.strokeStyle = "rgba(255,200,50,0.9)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(
              0,
              0,
              this.r + 10,
              0,
              Math.PI * 2 * (1 - this.telegraph / 30)
            );
            ctx.stroke();
          }
          ctx.restore();
        }
      }
      class Boss extends Enemy {
        constructor(x, y, level) {
          super(0, level);
          this.x = x;
          this.y = y;
          this.r = 50;
          this.color = "#9b59b6";
          this.level = level;
          this.hp = (300 + level * 80) * (1 + level * 0.2);
          this.maxHp = this.hp;
          this.dmg = 15 + level * 3;
          this.spd = 1.3;
          this.isBoss = true;
          this.name = "BOSS C·ªîNG " + level;
          this.skillDesc = "X·∫£ ƒë·∫°n ch√πm to√†n b·∫£n ƒë·ªì";
          this.attackTimer = 60;
        }
        update() {
          let p = Game.player;
          if (!p) return;
          let dx = p.x - this.x,
            dy = p.y - this.y;
          let dist = Math.hypot(dx, dy);
          if (dist > 300) {
            this.x += (dx / dist) * this.spd;
            this.y += (dy / dist) * this.spd;
          }
          this.attackTimer--;
          if (this.attackTimer <= 0 && dist < 3000) {
            this.shoot(p);
            this.attackTimer = Math.max(30, 70 - this.level * 2);
          }
          this.x += this.vx;
          this.y += this.vy;
          if (!this.dead && dist < this.r + p.r && p.invincible <= 0) {
            p.curHp -= this.dmg;
            p.invincible = 40;
            Game.cam.shake = Math.max(Game.cam.shake, 15);
            Game.cam.blood = 1.0;
            Game.fx.add(p.x, p.y, `-${Math.floor(this.dmg)}`, "#ff8888");
            Game.snd.playHurt();
            if (p.curHp <= 0) Game.over();
          }
        }
        shoot(target) {
          let ang = Math.atan2(target.y - this.y, target.x - this.x);
          for (let i = -1; i <= 1; i++) {
            Game.world.enemyBullets.push(
              new EnemyBullet(this.x, this.y, ang + i * 0.15, this.dmg * 0.8)
            );
          }
          Game.snd.playShoot("PLASMA");
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          if (this.attackTimer < 30) {
            ctx.shadowBlur = 20;
            ctx.shadowColor = "red";
          }
          let g = ctx.createRadialGradient(0, 0, this.r * 0.2, 0, 0, this.r);
          g.addColorStop(0, this.color);
          g.addColorStop(1, "#110015");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(0, 0, this.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.fillStyle = "#fff";
          ctx.font = "bold 14px Arial";
          ctx.textAlign = "center";
          ctx.fillText(this.name, 0, -this.r - 16);
          ctx.fillStyle = "#222";
          ctx.fillRect(-this.r, -this.r - 14, this.r * 2, 8);
          ctx.fillStyle = "#f39c12";
          ctx.fillRect(
            -this.r,
            -this.r - 14,
            this.r * 2 * (this.hp / this.maxHp),
            8
          );
          ctx.restore();
        }
      }
      class Bullet extends Entity {
        constructor(x, y, ang, dmg, isP, crit, style = "PISTOL") {
          super(
            x,
            y,
            isP ? 4 : 6,
            isP ? (crit ? "#fff" : "#f1c40f") : "#ff6b6b"
          );
          this.vx = Math.cos(ang) * 16;
          this.vy = Math.sin(ang) * 16;
          this.dmg = dmg;
          this.isP = isP;
          this.life = 80;
          this.crit = crit;
          this.style = style;
          if (style === "SNIPER") {
            this.life = 120;
            this.vx *= 1.5;
            this.vy *= 1.5;
          }
          if (style === "CANNON") {
            this.vx *= 0.7;
            this.vy *= 0.7;
            this.r = 8;
            this.life = 100;
            this.color = "#444";
          }
          if (style === "LASER") {
            this.vx *= 1.8;
            this.vy *= 1.8;
            this.r = 3;
            this.color = "#0f0";
            this.life = 40;
          }
          if (style === "PLASMA") {
            this.r = 6;
            this.color = "#0ff";
          }
        }
        update() {
          super.update();
          this.life--;
          if (this.life <= 0) this.dead = true;
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          if (this.style === "PLASMA") {
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.fillStyle = "#ccffff";
            ctx.beginPath();
            ctx.arc(0, 0, this.r, 0, Math.PI * 2);
            ctx.fill();
          } else if (this.style === "SNIPER") {
            ctx.rotate(Math.atan2(this.vy, this.vx));
            ctx.fillStyle = "#ff9";
            ctx.fillRect(-10, -2, 20, 4);
          } else if (this.style === "CANNON") {
            ctx.fillStyle = "#888";
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
          } else if (this.style === "LASER") {
            ctx.fillStyle = "#0f0";
            ctx.fillRect(-4, -1, 8, 2);
          } else if (this.style === "SHOTGUN") {
            ctx.fillStyle = "#ff6";
            ctx.fillRect(-4, -4, 8, 8);
          } else {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(0, 0, this.r, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
      }
      class EnemyBullet extends Entity {
        constructor(x, y, ang, dmg) {
          super(x, y, 8, "#ff0000");
          this.vx = Math.cos(ang) * 9;
          this.vy = Math.sin(ang) * 9;
          this.dmg = dmg;
          this.life = 100;
        }
        update() {
          super.update();
          this.life--;
          if (this.life <= 0) this.dead = true;
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          ctx.shadowBlur = 10;
          ctx.shadowColor = "red";
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(0, 0, this.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }
      class Particle {
        constructor(x, y, txt, col, life = 25) {
          this.x = x;
          this.y = y;
          this.txt = txt;
          this.col = col;
          this.life = life;
          this.max = life;
          this.vx = Utils.rand(-2, 2);
          this.vy = Utils.rand(-3, -1);
        }
        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vy += 0.1;
          this.life--;
        }
        draw(ctx) {
          if (
            this.x < Game.cam.x ||
            this.x > Game.cam.x + Config.w ||
            this.y < Game.cam.y ||
            this.y > Game.cam.y + Config.h
          )
            return;
          ctx.globalAlpha = Math.max(0, this.life / this.max);
          ctx.fillStyle = this.col;
          ctx.font = "bold 16px Arial";
          ctx.fillText(this.txt, this.x, this.y);
          ctx.globalAlpha = 1;
        }
      }
      class Drop {
        constructor(x, y, item) {
          this.x = x;
          this.y = y;
          this.item = item;
          this.r = 12;
          this.life = 60 * 60;
        }
        update() {
          this.life--;
          if (this.life <= 0) this.dead = true;
        }
        draw(ctx) {
          ctx.save();
          ctx.translate(this.x, this.y);
          if (this.item.rarity >= 3) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = "gold";
          }
          ctx.fillStyle = "#222";
          ctx.beginPath();
          ctx.arc(0, 0, this.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "gold";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          ctx.fillText(
            this.item.emoji || (this.item.stats.dmg ? "üî´" : "üõ°Ô∏è"),
            0,
            6
          );
          ctx.restore();
        }
      }

      const Game = {
        canvas: document.getElementById("cvs"),
        ctx: document.getElementById("cvs").getContext("2d", { alpha: true }),
        state: "MENU",
        frame: 0,
        lastTick: Utils.now(),
        player: null,
        userId: "GUEST_" + Utils.uuid(),
        world: {
          enemies: [],
          bullets: [],
          enemyBullets: [],
          parts: [],
          portal: null,
          drops: [],
        },
        cam: { x: 0, y: 0, shake: 0, flash: 0, blood: 0, warp: 0 },
        stage: { lvl: 1, kill: 0, req: 10, shop: [], bossSpawned: false },
        input: { w: 0, a: 0, s: 0, d: 0, space: 0, mouse: 0, mx: 0, my: 0 },
        fps: { last: Utils.now(), frame: 0, val: 60 },
        snd: {
          ctx: null,
          masterGain: null,
          init() {
            try {
              const AC = window.AudioContext || window.webkitAudioContext;
              if (!this.ctx) {
                this.ctx = new AC();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.15;
                this.masterGain.connect(this.ctx.destination);
                MusicSystem.init();
              }
            } catch (e) {
              console.warn("Audio not supported");
            }
          },
          playShoot(style) {
            this.beep(style === "SNIPER" ? 300 : 600, "square");
          },
          playHit() {
            this.beep(150, "sawtooth");
          },
          playHurt() {
            this.beep(100, "square");
          },
          playDash() {
            this.beep(400, "triangle");
          },
          playPowerUp() {
            this.beep(800, "sine");
          },
          playPickup() {
            this.beep(1200, "sine");
          },
          playLevel() {
            this.beep(560, "sine");
          },
          beep(freq, type) {
            if (!this.ctx) return;
            const o = this.ctx.createOscillator();
            const g = this.ctx.createGain();
            o.type = type;
            o.frequency.value = freq;
            o.connect(g);
            g.connect(this.masterGain);
            o.start();
            o.stop(this.ctx.currentTime + 0.1);
          },
        },
        fx: {
          add(x, y, t, c, small = false) {
            Game.world.parts.push(new Particle(x, y, t, c, small ? 40 : 60));
          },
          notify(msg) {
            let el = document.createElement("div");
            el.className = "noti-msg";
            el.innerText = msg;
            document.getElementById("noti-area").appendChild(el);
            setTimeout(() => el.remove(), 2000);
          },
          explode(x, y, color) {
            for (let i = 0; i < 18; i++) {
              let p = new Particle(
                x + Utils.rand(-6, 6),
                y + Utils.rand(-6, 6),
                "‚Ä¢",
                color,
                40 + Utils.randInt(0, 40)
              );
              p.vx = Utils.rand(-3, 3);
              p.vy = Utils.rand(-4, 2);
              Game.world.parts.push(p);
            }
            Game.cam.shake = Math.max(Game.cam.shake, 8);
            Game.cam.flash = 12;
          },
          burstTrail(x, y, ang) {
            for (let i = 0; i < 6; i++) {
              let p = new Particle(
                x - Math.cos(ang) * (6 + i * 3) + Utils.rand(-3, 3),
                y - Math.sin(ang) * (6 + i * 3) + Utils.rand(-3, 3),
                ".",
                "#ffd",
                18
              );
              p.vx = Utils.rand(-0.4, 0.4);
              p.vy = Utils.rand(-0.4, 0.4);
              Game.world.parts.push(p);
            }
          },
        },
        System: {
          saveGame() {
            if (!Game.player || !Game.userId) return;
            localStorage.setItem("inf_legends_user", Game.userId); // L∆∞u l·∫°i session
            let data = {
              p: {
                base: Game.player.baseStats,
                talents: Game.player.talents,
                lvl: Game.player.level,
                exp: Game.player.exp,
                req: Game.player.req,
                gold: Game.player.gold,
                inv: Game.player.inv,
                eq: Game.player.equip,
                curHp: Game.player.curHp,
              },
              s: { lvl: Game.stage.lvl },
            };
            fetch(`${API_URL}/save`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ userId: Game.userId, data: data }),
            })
              .then((res) => res.json())
              .then((json) => {
                if (json.success) Game.fx.notify("ƒê√£ l∆∞u Cloud!");
                else throw new Error("API Fail");
              })
              .catch((err) => {
                console.warn("Server offline, saving locally.");
                localStorage.setItem(
                  "inf_legends_save_" + Game.userId,
                  JSON.stringify(data)
                );
                Game.fx.notify("L∆∞u Offline (Server t·∫Øt)");
              });
          },
        },
        UI: {
          toggle(id) {
            let el = document.getElementById("screen-" + id);
            if (el.style.display === "flex") this.closeAll();
            else {
              this.closeAll();
              el.style.display = "flex";
              Game.state = "PAUSE";
              if (id === "inventory") this.renderInv();
              if (id === "shop") this.renderShop();
              if (id === "talents") this.renderTalents();
            }
          },
          closeAll() {
            document.querySelectorAll(".screen").forEach((e) => {
              if (e.id !== "screen-start" && e.id !== "screen-over")
                e.style.display = "none";
            });
            Game.state = "PLAY";
          },
          update() {
            if (!Game.player) return;
            let p = Game.player;
            document.getElementById("ui-stage").innerText = Game.stage.lvl;
            document.getElementById("ui-kill").innerText = Game.stage.kill;
            document.getElementById("ui-req").innerText = Game.stage.req;
            document.getElementById("ui-coin").innerText = p.gold;
            document.getElementById("bar-hp").style.width =
              (p.curHp / p.stats.maxHp) * 100 + "%";
            document.getElementById("txt-hp").innerText = `${Math.ceil(
              p.curHp
            )} / ${Math.ceil(p.stats.maxHp)}`;
            document.getElementById("bar-exp").style.width =
              (p.exp / p.req) * 100 + "%";
          },
          renderHotbar() {
            let div = document.getElementById("quick-slots");
            div.innerHTML = "";
            let counts = {};
            let items = [];
            Game.player.inv.forEach((i) => {
              if (i.type === "CONSUMABLE") {
                if (!counts[i.name]) {
                  counts[i.name] = { count: 0, item: i };
                  items.push(i);
                }
                counts[i.name].count++;
              }
            });
            items.forEach((i) => {
              let count = counts[i.name].count;
              let html = `<div class="q-slot" onclick="Game.UI.useQuick('${i.name}')">${i.emoji}<div class="q-count">${count}</div></div>`;
              div.innerHTML += html;
            });
          },
          useQuick(name) {
            let idx = Game.player.inv.findIndex((i) => i.name === name);
            if (idx !== -1) {
              if (Game.player.useItem(Game.player.inv[idx])) {
                Game.player.inv.splice(idx, 1);
                this.renderHotbar();
              }
            }
          },
          renderInv() {
            let g = document.getElementById("grid-inv");
            g.innerHTML = "";
            let gear = Game.player.inv.filter((i) => i.type !== "CONSUMABLE");
            gear.forEach((item) => {
              let idx = Game.player.inv.indexOf(item);
              let eq =
                Game.player.equip.wp === item || Game.player.equip.ar === item;
              let icon = item.emoji || (item.stats.dmg ? "üî´" : "üõ°Ô∏è");
              let statsStr = item.stats.dmg
                ? `DMG: ${item.stats.dmg} ‚Ä¢ R:${item.stats.rate}`
                : `HP: ${item.stats.hp}`;
              let html = `<div class="card rarity-${
                item.rarity
              }" onclick="Game.UI.actionInv(${idx})"><div style="display:flex; align-items:center;"><div class="inv-emoji">${icon}</div><div style="font-weight:bold">${
                item.name
              }</div></div><div style="font-size:12px; color:#aaa">${
                item.type
              } | Lv.${
                item.level
              }</div><div style="font-size:13px; margin-top:6px">${statsStr}</div>${
                eq ? '<span class="card-tag">EQUIPPED</span>' : ""
              } <div style="margin-top:8px; font-size:12px; color:gold">Sell: ${Math.floor(
                item.price / 2
              )}$</div></div>`;
              g.innerHTML += html;
            });
            if (gear.length === 0)
              g.innerHTML =
                "<div style='grid-column:1/-1;text-align:center;color:#666'>Kh√¥ng c√≥ trang b·ªã.</div>";
          },
          actionInv(idx) {
            let item = Game.player.inv[idx];
            if (!item) return;
            if (
              confirm(
                `Trang b·ªã hay B√°n m√≥n [${
                  item.name
                }]?\nOK = Trang b·ªã\nCancel = B√°n (+${Math.floor(
                  item.price / 2
                )}$)`
              )
            ) {
              if (item.type === "WEAPON") Game.player.equip.wp = item;
              else Game.player.equip.ar = item;
            } else {
              if (Game.player.equip.wp === item) Game.player.equip.wp = null;
              if (Game.player.equip.ar === item) Game.player.equip.ar = null;
              Game.player.inv.splice(idx, 1);
              Game.player.gold += Math.floor(item.price / 2);
            }
            this.renderInv();
          },
          renderShop() {
            let g = document.getElementById("grid-shop");
            g.innerHTML = "";
            Game.stage.shop.forEach((item, idx) => {
              let icon = item.emoji || (item.stats.dmg ? "üî´" : "üõ°Ô∏è");
              let stat =
                item.type === "CONSUMABLE"
                  ? item.desc
                  : item.stats.dmg
                  ? `DMG:${item.stats.dmg}`
                  : `HP:${item.stats.hp}`;
              let html = `<div class="card rarity-${item.rarity}" onclick="Game.UI.buy(${idx})"><div style="display:flex; align-items:center;"><div class="inv-emoji">${icon}</div><div style="font-weight:bold">${item.name}</div></div><div style="font-size:12px; color:#aaa">${item.type}</div><div style="font-size:13px; margin-top:6px">${stat}</div><div style="color:gold; font-weight:bold; margin-top:8px">${item.price}$</div></div>`;
              g.innerHTML += html;
            });
          },
          buy(idx) {
            let item = Game.stage.shop[idx];
            if (!item) return;
            if (Game.player.gold >= item.price) {
              Game.player.gold -= item.price;
              Game.player.inv.push(item);
              Game.stage.shop.splice(idx, 1);
              this.renderShop();
              Game.fx.notify("Mua th√†nh c√¥ng!");
              Game.snd.playHit();
              this.renderHotbar();
            } else Game.fx.notify("Kh√¥ng ƒë·ªß ti·ªÅn!");
          },
          renderTalents() {
            let d = document.getElementById("list-talents");
            d.innerHTML = "";
            Config.talents.forEach((t) => {
              let lvl = Game.player.talents[t.id];
              let cost = t.base + lvl * t.inc;
              let html = `<div class="talent-row"><div><div style="font-weight:bold; font-size:16px; color:var(--main)">${
                t.name
              }</div><div style="color:#aaa">C·∫•p hi·ªán t·∫°i: ${lvl} (+${(
                lvl * t.val
              ).toFixed(
                1
              )})</div></div><button class="btn" onclick="Game.UI.upTalent('${
                t.id
              }')">N√¢ng c·∫•p (${cost}$)</button></div>`;
              d.innerHTML += html;
            });
          },
          upTalent(id) {
            let t = Config.talents.find((x) => x.id === id);
            let lvl = Game.player.talents[id];
            let cost = t.base + lvl * t.inc;
            if (Game.player.gold >= cost) {
              Game.player.gold -= cost;
              Game.player.talents[id]++;
              this.renderTalents();
              Game.fx.notify("N√¢ng c·∫•p th√†nh c√¥ng!");
              Game.snd.playLevel();
            } else Game.fx.notify("Thi·∫øu ti·ªÅn!");
          },
        },
        over() {
          this.state = "OVER";
          document.getElementById("screen-over").style.display = "block";
          document.getElementById("over-stage").innerText = this.stage.lvl;
          MusicSystem.stop();
        },
        drawBackground() {
          this.ctx.fillStyle = "#111";
          this.ctx.fillRect(this.cam.x, this.cam.y, Config.w, Config.h);
          this.ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
          this.ctx.lineWidth = 2;
          this.ctx.beginPath();
          let gridSize = 100;
          let startX = Math.floor(this.cam.x / gridSize) * gridSize;
          let startY = Math.floor(this.cam.y / gridSize) * gridSize;
          for (let x = startX; x < this.cam.x + Config.w; x += gridSize) {
            this.ctx.moveTo(x, this.cam.y);
            this.ctx.lineTo(x, this.cam.y + Config.h);
          }
          for (let y = startY; y < this.cam.y + Config.h; y += gridSize) {
            this.ctx.moveTo(this.cam.x, y);
            this.ctx.lineTo(this.cam.x + Config.w, y);
          }
          this.ctx.stroke();
        },
        drawWarp() {
          this.ctx.fillStyle = "#000";
          this.ctx.fillRect(0, 0, Config.w, Config.h);
          this.ctx.fillStyle = `rgba(52, 152, 219, ${Math.random() * 0.5})`;
          this.ctx.beginPath();
          let r = (this.frame % 60) * 10;
          this.ctx.arc(Config.w / 2, Config.h / 2, r, 0, Math.PI * 2);
          this.ctx.fill();
          this.ctx.fillStyle = "#fff";
          this.ctx.font = "30px Consolas";
          this.ctx.textAlign = "center";
          this.ctx.fillText("WARPING...", Config.w / 2, Config.h / 2);
        },
        updateList(list) {
          for (let i = list.length - 1; i >= 0; i--) {
            let e = list[i];
            if (e.dead) {
              list.splice(i, 1);
              continue;
            }
            e.update();
            if (
              e.x + e.r > this.cam.x &&
              e.x - e.r < this.cam.x + Config.w &&
              e.y + e.r > this.cam.y &&
              e.y - e.r < this.cam.y + Config.h
            )
              e.draw(this.ctx);
          }
        },
        checkHUD() {
          let hud = document.getElementById("monster-hud");
          let boss = this.world.enemies.find((e) => e.isBoss && !e.dead);
          if (boss) {
            hud.classList.add("active");
            document.getElementById("m-name").innerText = boss.name;
            document.getElementById("m-power").innerText = Math.floor(boss.dmg);
            document.getElementById("m-hp").innerText =
              Math.floor(boss.hp) + " / " + Math.floor(boss.maxHp);
            document.getElementById("m-skill").innerText = boss.skillDesc;
          } else hud.classList.remove("active");
        },
        drawMinimap() {
          let size = 120;
          let pad = 20;
          let mapX = Config.w - size - pad;
          let mapY = pad + 60;
          this.ctx.save();
          this.ctx.translate(this.cam.x + mapX, this.cam.y + mapY);
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
          this.ctx.strokeStyle = "#444";
          this.ctx.lineWidth = 2;
          this.ctx.fillRect(0, 0, size, size);
          this.ctx.strokeRect(0, 0, size, size);
          let scale = 0.05;
          let cx = size / 2;
          let cy = size / 2;
          this.ctx.fillStyle = "#0f0";
          this.ctx.beginPath();
          this.ctx.arc(cx, cy, 3, 0, Math.PI * 2);
          this.ctx.fill();
          this.ctx.fillStyle = "#f00";
          for (let e of this.world.enemies) {
            let ex = (e.x - this.player.x) * scale + cx;
            let ey = (e.y - this.player.y) * scale + cy;
            if (ex > 0 && ex < size && ey > 0 && ey < size) {
              this.ctx.beginPath();
              this.ctx.arc(ex, ey, e.isBoss ? 5 : 2, 0, Math.PI * 2);
              this.ctx.fill();
            }
          }
          if (this.world.portal) {
            this.ctx.fillStyle = "gold";
            let px = (this.world.portal.x - this.player.x) * scale + cx;
            let py = (this.world.portal.y - this.player.y) * scale + cy;
            if (px > 0 && px < size && py > 0 && py < size) {
              this.ctx.beginPath();
              this.ctx.arc(px, py, 4, 0, Math.PI * 2);
              this.ctx.fill();
            }
          }
          this.ctx.restore();
        },
        init() {
          this.resize();
          window.addEventListener("resize", () => this.resize());
          this.bindInput();
          this.snd.init();
          document.getElementById("btn-inv").onclick = () =>
            this.UI.toggle("inventory");
          document.getElementById("btn-shop").onclick = () =>
            this.UI.toggle("shop");
          document.getElementById("btn-tal").onclick = () =>
            this.UI.toggle("talents");
          document.getElementById("btn-save").onclick = () =>
            this.System.saveGame();
          window.addEventListener("keydown", (e) => {
            if (e.code === "KeyB") this.UI.toggle("inventory");
            if (e.code === "KeyP") this.UI.toggle("shop");
            if (e.code === "KeyT") this.UI.toggle("talents");
          });
          // --- AUTO LOAD SESSION ---
          const savedUser = localStorage.getItem("inf_legends_user");
          if (savedUser) {
            document.getElementById("inp-userid").value = savedUser;
            this.userId = savedUser;
          }
          this.loop();
        },
        startNew() {
          let inp = document.getElementById("inp-userid").value.trim();
          if (inp) {
            this.userId = inp;
            localStorage.setItem("inf_legends_user", inp);
          }
          this.start(false);
        },
        start(isLoading = false) {
          if (this.snd.ctx && this.snd.ctx.state === "suspended")
            this.snd.ctx.resume();
          MusicSystem.startBattleMusic();
          this.player = new Player();
          if (!isLoading) {
            let gun = ItemGenerator.create(1);
            gun.type = "WEAPON";
            gun.name = "S√∫ng T·∫≠p S·ª±";
            gun.stats = { dmg: 8, rate: 18, multi: 1, crit: 0 };
            gun.emoji = "üî´";
            gun.subType = "PISTOL";
            this.player.inv.push(gun);
            this.player.equip.wp = gun;
          }
          this.resetStage(1);
          this.state = "PLAY";
          document.getElementById("screen-start").style.display = "none";
          if (!isLoading) this.System.saveGame(); // Only auto-save if NEW game
          this.UI.renderHotbar();
        },
        async loadFromHybrid() {
          let inp = document.getElementById("inp-userid").value.trim();
          if (inp) {
            this.userId = inp;
            localStorage.setItem("inf_legends_user", inp);
          }
          if (this.snd.ctx && this.snd.ctx.state === "suspended")
            this.snd.ctx.resume();
          MusicSystem.startBattleMusic();
          try {
            const res = await fetch(`${API_URL}/load/${this.userId}`);
            const json = await res.json();
            if (json.success && json.data) {
              this.loadData(json.data);
              this.fx.notify("ƒê√£ t·∫£i t·ª´ Cloud!");
            } else throw new Error("No server data");
          } catch (e) {
            console.log("Using LocalStorage fallback");
            let localData = localStorage.getItem(
              "inf_legends_save_" + this.userId
            );
            if (localData) {
              this.loadData(JSON.parse(localData));
              this.fx.notify("ƒê√£ t·∫£i t·ª´ Offline Save!");
            } else alert("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu c≈©!");
          }
        },
        loadData(d) {
          this.start(true);
          this.player.baseStats = d.p.base;
          this.player.talents = d.p.talents || {
            hp: 0,
            dmg: 0,
            spd: 0,
            greed: 0,
          };
          this.player.level = d.p.lvl;
          this.player.exp = d.p.exp;
          this.player.req = d.p.req;
          this.player.gold = d.p.gold;
          this.player.inv = d.p.inv;
          this.player.equip = d.p.eq;
          if (d.p.curHp) this.player.curHp = d.p.curHp;
          this.resetStage(d.s.lvl);
          this.UI.renderHotbar();
        },
        resize() {
          const c = this.canvas,
            dpr = Config.dpr;
          c.width = Math.floor(window.innerWidth * dpr);
          c.height = Math.floor(window.innerHeight * dpr);
          c.style.width = window.innerWidth + "px";
          c.style.height = window.innerHeight + "px";
          this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          Config.w = window.innerWidth;
          Config.h = window.innerHeight;
        },
        bindInput() {
          let k = this.input;
          window.onkeydown = (e) => {
            if (e.code == "KeyW") k.w = 1;
            if (e.code == "KeyS") k.s = 1;
            if (e.code == "KeyA") k.a = 1;
            if (e.code == "KeyD") k.d = 1;
            if (e.code == "Space") k.space = 1;
            if (e.code == "Escape") this.UI.closeAll();
          };
          window.onkeyup = (e) => {
            if (e.code == "KeyW") k.w = 0;
            if (e.code == "KeyS") k.s = 0;
            if (e.code == "KeyA") k.a = 0;
            if (e.code == "KeyD") k.d = 0;
            if (e.code == "Space") k.space = 0;
          };
          window.onmousedown = (e) => {
            k.mouse = 1;
            k.mx = e.clientX;
            k.my = e.clientY;
          };
          window.onmouseup = () => (k.mouse = 0);
          window.onmousemove = (e) => {
            k.mx = e.clientX;
            k.my = e.clientY;
          };
        },
        resetStage(lvl) {
          this.state = "TRANSITION";
          this.stage.lvl = lvl;
          this.stage.kill = 0;
          this.stage.req = 10 + Math.floor(lvl * 1.5);
          this.stage.bossSpawned = false;
          this.world.enemies = [];
          this.world.bullets = [];
          this.world.enemyBullets = [];
          this.world.portal = null;
          this.world.drops = [];
          this.player.x = 0;
          this.player.y = 0;
          this.player.invincible = 120;
          this.stage.shop = [];
          for (let i = 0; i < 30; i++)
            this.stage.shop.push(ItemGenerator.create(lvl));
          this.cam.warp = 0;
          this.cam.flash = 20;
          setTimeout(() => {
            this.state = "PLAY";
            this.fx.add(0, -100, `STAGE ${lvl}`, "#fff", true);
            this.fx.notify(`B·∫ÆT ƒê·∫¶U STAGE ${lvl}`);
            this.System.saveGame();
          }, 800);
        },
        spawnBossLoot(boss) {
          let gold =
            Utils.randInt(200, 500) +
            Math.floor(this.player.talents.greed * 50);
          this.player.gold += gold;
          this.fx.add(boss.x, boss.y, `+${gold}$`, "gold");
          let rand = Math.random() * 100;
          let dropItem = null;
          let lvl = this.stage.lvl;
          if (lvl % 10 === 0) {
            if (rand <= 0.5) {
              dropItem = ItemGenerator.create(lvl, 5, 1.5);
              dropItem.name = "üëë " + dropItem.name + " (GOD)";
              this.fx.notify("!!! C·ª∞C PH·∫®M XU·∫§T TH·∫æ !!!");
            } else if (rand <= 1.5) {
              dropItem = ItemGenerator.create(lvl, 3, 1.2);
              dropItem.name = "‚ú® " + dropItem.name + " (Rare)";
              this.fx.notify("R∆°i ƒë·ªì Hi·∫øm!");
            } else {
              this.fx.notify("Boss ·∫®n ch·ªâ r∆°i V√†ng...");
            }
          } else {
            if (rand <= 5) {
              dropItem = ItemGenerator.create(lvl, 4, 1.1);
              this.fx.notify("BOSS R∆†I ƒê·ªí VIP!");
            } else if (rand <= 45) {
              dropItem = ItemGenerator.create(lvl, -1, 1.0);
              this.fx.notify("Nh·∫∑t ƒë∆∞·ª£c trang b·ªã.");
            }
          }
          if (dropItem)
            Game.world.drops.push(new Drop(boss.x, boss.y, dropItem));
        },
        loop() {
          requestAnimationFrame(() => this.loop());
          const now = Utils.now();
          this.lastTick = now;
          this.fps.frame++;
          if (now - this.fps.last >= 500) {
            this.fps.val = Math.round(
              (this.fps.frame * 1000) / (now - this.fps.last)
            );
            this.fps.last = now;
            this.fps.frame = 0;
            document.getElementById("ui-fps").innerText = `${this.fps.val} FPS`;
          }
          this.frame++;
          this.ctx.clearRect(0, 0, Config.w, Config.h);
          if (this.world.parts.length > 80)
            this.world.parts.splice(0, this.world.parts.length - 80);
          if (this.world.bullets.length > 100) this.world.bullets.splice(0, 1);
          if (this.state === "TRANSITION" || this.cam.warp > 0) this.drawWarp();
          else this.drawBackground();
          if (this.cam.shake > 0) {
            this.cam.x += Utils.rand(-3, 3);
            this.cam.y += Utils.rand(-3, 3);
            this.cam.shake--;
          }
          if (this.player) {
            this.cam.x = Utils.lerp(
              this.cam.x,
              this.player.x - Config.w / 2,
              0.1
            );
            this.cam.y = Utils.lerp(
              this.cam.y,
              this.player.y - Config.h / 2,
              0.1
            );
          }
          this.ctx.save();
          this.ctx.translate(-this.cam.x, -this.cam.y);
          if (this.state === "PLAY" || this.state === "TRANSITION") {
            if (
              this.world.enemies.length <
                Math.min(60, 20 + this.stage.lvl * 2) &&
              this.frame % 50 === 0 &&
              !this.stage.bossSpawned
            ) {
              let type = Math.random() < 0.18 ? 1 : Math.random() < 0.2 ? 2 : 0;
              this.world.enemies.push(new Enemy(type, this.stage.lvl));
            }
            if (this.stage.kill >= this.stage.req && !this.stage.bossSpawned) {
              this.stage.bossSpawned = true;
              this.fx.notify("BOSS XU·∫§T HI·ªÜN! DI·ªÜT ƒê·ªÇ M·ªû C·ªîNG!");
              Game.snd.playPowerUp();
              let b1 = new Boss(
                this.player.x + 300,
                this.player.y,
                this.stage.lvl
              );
              let b2 = new Boss(
                this.player.x - 300,
                this.player.y,
                this.stage.lvl
              );
              this.world.enemies.push(b1, b2);
            }
            if (this.stage.bossSpawned && !this.world.portal) {
              let bossAlive = this.world.enemies.some((e) => e.isBoss);
              if (!bossAlive) {
                this.world.portal = new Portal(
                  this.player.x + 400,
                  this.player.y
                );
                this.fx.notify("C·ªîNG KH√îNG GIAN ƒê√É M·ªû!");
                Game.snd.playPowerUp();
              }
            }
            if (this.world.portal) {
              this.world.portal.update();
              this.world.portal.draw(this.ctx);
              let dist = Utils.dist(
                this.player.x,
                this.player.y,
                this.world.portal.x,
                this.world.portal.y
              );
              if (dist > Config.w / 2) {
                let ang = Math.atan2(
                  this.world.portal.y - this.player.y,
                  this.world.portal.x - this.player.x
                );
                this.ctx.fillStyle = "#2ecc71";
                this.ctx.beginPath();
                this.ctx.arc(
                  this.player.x + Math.cos(ang) * 200,
                  this.player.y + Math.sin(ang) * 200,
                  10,
                  0,
                  Math.PI * 2
                );
                this.ctx.fill();
              }
              if (dist < 50 && this.state === "PLAY") {
                this.cam.warp = 30;
                this.snd.playPowerUp();
                this.resetStage(this.stage.lvl + 1);
              }
            }
            this.player.update(this.input, this.cam);
            this.player.draw(this.ctx);
            this.updateList(this.world.bullets);
            this.updateList(this.world.enemyBullets);
            this.updateList(this.world.enemies);
            this.updateList(this.world.parts);
            this.updateList(this.world.drops);
            for (let b of this.world.bullets) {
              if (b.isP) {
                for (let e of this.world.enemies) {
                  if (
                    !b.dead &&
                    !e.dead &&
                    Utils.dist(b.x, b.y, e.x, e.y) < e.r + b.r
                  ) {
                    b.dead = true;
                    e.hp -= b.dmg;
                    this.fx.explode(e.x, e.y, b.crit ? "#ffffff" : "#fffcaa");
                    this.fx.add(e.x, e.y, Math.floor(b.dmg), "#fff");
                    Game.snd.playHit();
                    if (e.hp <= 0) {
                      e.dead = true;
                      this.stage.kill++;
                      let gold =
                        Utils.randInt(6, 18) +
                        Math.floor(this.player.talents.greed * 10);
                      this.player.gold += gold;
                      this.player.exp += 20;
                      this.fx.add(e.x, e.y, `+${gold}$`, "gold");
                      if (e.isBoss) this.spawnBossLoot(e);
                      if (this.player.exp >= this.player.req) {
                        this.player.level++;
                        this.player.exp = 0;
                        this.player.req = Math.floor(this.player.req * 1.25);
                        this.player.curHp = this.player.stats.maxHp;
                        this.fx.add(
                          this.player.x,
                          this.player.y - 60,
                          "LEVEL UP!",
                          "#2ecc71"
                        );
                        this.snd.playLevel();
                      }
                    }
                  }
                }
              }
            }
            for (let b of this.world.enemyBullets) {
              if (
                !b.dead &&
                Utils.dist(b.x, b.y, this.player.x, this.player.y) <
                  b.r + this.player.r &&
                this.player.invincible <= 0
              ) {
                b.dead = true;
                this.player.curHp -= b.dmg;
                this.player.invincible = 30;
                Game.cam.shake = 10;
                Game.cam.blood = 0.8;
                Game.snd.playHurt();
                Game.fx.add(
                  this.player.x,
                  this.player.y,
                  `-${Math.floor(b.dmg)}`,
                  "#e74c3c"
                );
                if (this.player.curHp <= 0) this.over();
              }
            }
            for (let i = this.world.drops.length - 1; i >= 0; i--) {
              let d = this.world.drops[i];
              if (
                Utils.dist(d.x, d.y, this.player.x, this.player.y) <
                d.r + this.player.r
              ) {
                this.player.inv.push(d.item);
                this.fx.add(
                  this.player.x,
                  this.player.y - 20,
                  `+${d.item.name}`,
                  "#fff"
                );
                this.fx.notify("Nh·∫∑t ƒë∆∞·ª£c v·∫≠t ph·∫©m!");
                this.snd.playPickup();
                this.world.drops.splice(i, 1);
                this.UI.renderHotbar();
              }
            }
            this.checkHUD();
          } else {
            if (this.player) this.player.draw(this.ctx);
          }
          this.ctx.restore();
          if (this.state === "PLAY" && this.player) this.drawMinimap();
          this.UI.update();
          if (this.cam.flash > 0) {
            this.cam.flash--;
            this.fullscreenFlash(this.cam.flash / 40, "#fff");
          }
          if (this.cam.blood > 0) {
            this.fullscreenFlash(this.cam.blood * 0.2, "red");
            this.cam.blood -= 0.05;
          }
        },
        fullscreenFlash(str, color = "#fff") {
          this.ctx.save();
          this.ctx.fillStyle = color;
          this.ctx.globalAlpha = Math.min(0.2, str);
          this.ctx.fillRect(0, 0, Config.w, Config.h);
          this.ctx.restore();
        },
      };
      window.onload = () => {
        Game.init();
      };
    </script>
  </body>
</html>
